# Домашнее задание: Управление маятником в MuJoCo

## Цель
**Реализовать и сравнить три подхода для задачи swing-up (подъёма наверх) простого маятника в MuJoCo.** Маятник моделируется на основе XML-модели, из которой необходимо извлечь его параметры - массу груза `m` и длину маятника `l`.

Сама модель маятника находится в файле `simple_pendulum.xml`.

**Задание выполнять в файле `pendulum_control.py`**. Там уже реализована привязка к Mujoco через самописный класс, вам остаётся реализовать исключительно логику управляющего контроллера.

## Динамика маятника
Динамическое уравнение для вращающегося маятника:

$$
m l \ddot{\theta} + b \dot{\theta} + m g l \sin\theta = \tau
$$

Где:
- $\theta$ — угол отклонения маятника от вертикали
- $b$ — коэффициент трения (в файле модели можно включать/выключать в параметрах шарнира - `damping`)
- $m$ — масса
- $g$ — ускорение свободного падения
- $l$ — расстояние от оси вращения до центра масс
- $\tau$ — управляющий момент

> **Подсказка:** Извлеките параметры `m`, `l` из XML файла модели и запишите их в файл `pendulum_control.py`.

---

## 1. Управление через смену гравитации ("переворот гравитации")
**Идея:** Меняем вектор гравитации таким образом, чтобы он "толкал" маятник вверх.

- Задайте небольшое трение в шарнире (параметр `damping` в файле модели).
- Выключите ограничение на момент в двигателе (`ctrllimited="false"`).
- Посмотрите внимательно на уравнение динамики маятника и подумайте, как можно реализовать управление, чтобы "изменить" вектор гравитации.


> **✨ Подсказка:**
> Что-то нужно сделать с членом $ m g l \sin\theta$

---

## 2. Управление ПД-регулятором (неограниченные моменты на двигателе)
**Идея:** Применить ПД-регулятор для поднятия маятника в верхнюю точку:

$$
\tau = K_p (\theta_{des} - \theta) + K_d (\dot{\theta}_{des} - \dot{\theta})
$$

Где:
- $\theta_{des}$ — заданный угол отклонения маятника (верхняя точка - это $\pi$)
- $\dot{\theta}_{des}$ — заданный угловая скорость маятника (раз мы хотим, чтобы маятник остановился в верхней точке, то задаём нулём)
- $K_p$ и $K_d$ - пропорциональный и дифференциальный коэффициенты регулятора соответственно. $K_p$ отвечает за быстродействие, $K_d$ - за устранение перерегулирования (советую погуглить, тема интересная)

Реализуйте ПД-регулятор и подумайте, почему такое подход не получится использовать на реальном железе. В этом может помочь график управляющего воздействия

---

## 3. Energy-shaping подход (с ограниченным моментом)
В условиях ограничения момента на двигателе достаточно сложно достичь верхней точки так, как мы это делали без ограничений на момент в предыдущих подходах. Значит, необходимо применить energy-shaping подход для раскачки маятника, чтобы достичь верхнего положения. Суть его заключается в наборе достаточной энергии для того, чтобы маятник смог достичь верхнего положения. Хорошей аналогией является "солнышко", которое делали ребята на качели, постепенно раскачиваясь.

Для раскачки воспользуемся формулой:

$$
\tau = k \cdot (E_{des} - E) \cdot \dot{\theta} \cos(\theta)
$$

Где:
- $E = \frac{1}{2} m l \dot{\theta}^2 - m g l cos\theta$ — полная энергия маятника
- $E_{des}$ — желаемая энергия в верхней точке (подумайте, какой она должна быть в верхней точке)
- $k$ — коэффициент усиления

Чтобы реализовать такое управление:
- Включите ограничение на момент в двигателе (`ctrllimited="true"`)
- Подумайте, каким должно быть $E_{des}$
- На каждом временном шагу рассчитывайте текущую энергию маятника $E$ (формула приведена выше)

> **✨ Подсказка:**
> Если вы увидите, что маятник никуда не раскачивается, то посмотрите внимательно на формулу рассчитанного момента и вашу начальную скорость (очевидно, что при нулевой скорости маятник не начнёт раскачиваться)

Когда вы это сделаете, вы обнаружите, что достигая верхней точки, маятник её перелетает, не в силах в ней удержаться. Дело в том, что energy-shaping подходит только для накачки необходимой энергии, а для удержания заданной позиции необходим уже другой подход. Например, ПД-регулятор, который вы реализовали на предыдущем шаге.

Логика вашего итогового контроллера будет примерно следующей:
```py
Если  theta близок к Пи:
        tau = ПД-регулятор
    Иначе:
        tau = energy-shaping
```

**Имейте в виду, что numpy, как и mujoco, оперируют углами в радианах, поэтому если хотите использовать углы в градусах, не забывайте их переводить в радианы с помощью np.grad2rad()**

> **✨ Огромная подсказка:**
> 
```py
if (np.deg2rad(180) - theta) <= np.deg2rad(25):
        tau =  Kp * (np.deg2rad(180) - theta) - Kd * dtheta
    else:
        theta = wrap_to_pi(theta)
        E = ...
        tau = ...
tau = np.clip(tau, -5, 5)
```

---

## Что сдать

- Заполненный `.py` файл с названием `pendulum_control_{фамилия}.py`

---

## Дедлайн

_04.07.2025 23:59_

---

Успехов!
